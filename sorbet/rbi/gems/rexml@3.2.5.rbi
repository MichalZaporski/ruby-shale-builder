# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rexml` gem.
# Please instead update this file by running `bin/tapioca gem rexml`.


# source://rexml//lib/rexml/encoding.rb#4
module REXML::Encoding
  # source://rexml//lib/rexml/encoding.rb#29
  def decode(string); end

  # source://rexml//lib/rexml/encoding.rb#25
  def encode(string); end

  # ID ---> Encoding name
  #
  # source://rexml//lib/rexml/encoding.rb#6
  def encoding; end

  # source://rexml//lib/rexml/encoding.rb#7
  def encoding=(encoding); end

  private

  # source://rexml//lib/rexml/encoding.rb#34
  def find_encoding(name); end
end

# A Source that wraps an IO.  See the Source class for method
# documentation
#
# source://rexml//lib/rexml/source.rb#159
class REXML::IOSource < ::REXML::Source
  # block_size has been deprecated
  #
  # @return [IOSource] a new instance of IOSource
  #
  # source://rexml//lib/rexml/source.rb#163
  def initialize(arg, block_size = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#215
  def consume(pattern); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#244
  def current_line; end

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/source.rb#235
  def empty?; end

  # source://rexml//lib/rexml/source.rb#219
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#239
  def position; end

  # source://rexml//lib/rexml/source.rb#207
  def read; end

  # source://rexml//lib/rexml/source.rb#184
  def scan(pattern, cons = T.unsafe(nil)); end

  private

  # source://rexml//lib/rexml/source.rb#286
  def encoding_updated; end

  # source://rexml//lib/rexml/source.rb#266
  def readline; end
end

# source://rexml//lib/rexml/parseexception.rb#3
class REXML::ParseException < ::RuntimeError
  # @return [ParseException] a new instance of ParseException
  #
  # source://rexml//lib/rexml/parseexception.rb#6
  def initialize(message, source = T.unsafe(nil), parser = T.unsafe(nil), exception = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parseexception.rb#48
  def context; end

  # Returns the value of attribute continued_exception.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception; end

  # Sets the attribute continued_exception
  #
  # @param value the value to set the attribute continued_exception to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#43
  def line; end

  # Returns the value of attribute parser.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser; end

  # Sets the attribute parser
  #
  # @param value the value to set the attribute parser to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#38
  def position; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#13
  def to_s; end
end

# = Using the Pull Parser
# <em>This API is experimental, and subject to change.</em>
#  parser = PullParser.new( "<a>text<b att='val'/>txet</a>" )
#  while parser.has_next?
#    res = parser.next
#    puts res[1]['att'] if res.start_tag? and res[0] == 'b'
#  end
# See the PullEvent class for information on the content of the results.
# The data is identical to the arguments passed for the various events to
# the StreamListener API.
#
# Notice that:
#  parser = PullParser.new( "<a>BAD DOCUMENT" )
#  while parser.has_next?
#    res = parser.next
#    raise res[1] if res.error?
#  end
#
# Nat Price gave me some good ideas for the API.
#
# source://rexml//lib/rexml/parsers/baseparser.rb#29
class REXML::Parsers::BaseParser
  # @return [BaseParser] a new instance of BaseParser
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#115
  def initialize(source); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#120
  def add_listener(listener); end

  # Returns true if there are no more events
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#146
  def empty?; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#438
  def entity(reference, entities); end

  # Returns true if there are more events.  Synonymous with !empty?
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#151
  def has_next?; end

  # Escapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#449
  def normalize(input, entities = T.unsafe(nil), entity_filter = T.unsafe(nil)); end

  # Peek at the +depth+ event in the stack.  The first element on the stack
  # is at depth 0.  If +depth+ is -1, will parse to the end of the input
  # stream and return the last event, which is always :end_document.
  # Be aware that this causes the stream to be parsed up to the +depth+
  # event, so you can effectively pre-parse the entire document (pull the
  # entire thing into memory) using this method.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#167
  def peek(depth = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#136
  def position; end

  # Returns the next event.  This is a +PullEvent+ object.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#182
  def pull; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#124
  def source; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#126
  def stream=(source); end

  # Unescapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#465
  def unnormalize(string, entities = T.unsafe(nil), filter = T.unsafe(nil)); end

  # Push an event back on the head of the stream.  This method
  # has (theoretically) infinite depth.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#157
  def unshift(token); end

  private

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#495
  def need_source_encoding_update?(xml_declaration_encoding); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#589
  def parse_attributes(prefixes, curr_ns); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#514
  def parse_id(base_error_message, accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#542
  def parse_id_invalid_details(accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#501
  def parse_name(base_error_message); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#580
  def process_instruction; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#190
  def pull_event; end
end

# source://rexml//lib/rexml/parsers/baseparser.rb#102
REXML::Parsers::BaseParser::EXTERNAL_ID_PUBLIC = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#103
REXML::Parsers::BaseParser::EXTERNAL_ID_SYSTEM = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#104
REXML::Parsers::BaseParser::PUBLIC_ID = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#38
REXML::Parsers::BaseParser::QNAME = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#37
REXML::Parsers::BaseParser::QNAME_STR = T.let(T.unsafe(nil), String)

# A Source can be searched for patterns, and wraps buffers and other
# objects and provides consumption of text
#
# source://rexml//lib/rexml/source.rb#31
class REXML::Source
  include ::REXML::Encoding

  # Constructor
  # value, overriding all encoding detection
  #
  # @param arg must be a String, and should be a valid XML document
  # @param encoding if non-null, sets the encoding of the source to this
  # @return [Source] a new instance of Source
  #
  # source://rexml//lib/rexml/source.rb#43
  def initialize(arg, encoding = T.unsafe(nil)); end

  # The current buffer (what we're going to read next)
  #
  # source://rexml//lib/rexml/source.rb#34
  def buffer; end

  # source://rexml//lib/rexml/source.rb#87
  def consume(pattern); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#117
  def current_line; end

  # @return [Boolean] true if the Source is exhausted
  #
  # source://rexml//lib/rexml/source.rb#108
  def empty?; end

  # Returns the value of attribute encoding.
  #
  # source://rexml//lib/rexml/source.rb#37
  def encoding; end

  # Inherited from Encoding
  # Overridden to support optimized en/decoding
  #
  # source://rexml//lib/rexml/source.rb#56
  def encoding=(enc); end

  # The line number of the last consumed text
  #
  # source://rexml//lib/rexml/source.rb#36
  def line; end

  # source://rexml//lib/rexml/source.rb#101
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#91
  def match_to(char, pattern); end

  # source://rexml//lib/rexml/source.rb#95
  def match_to_consume(char, pattern); end

  # source://rexml//lib/rexml/source.rb#112
  def position; end

  # source://rexml//lib/rexml/source.rb#84
  def read; end

  # Scans the source for a given pattern.  Note, that this is not your
  # usual scan() method.  For one thing, the pattern argument has some
  # requirements; for another, the source can be consumed.  You can easily
  # confuse this method.  Originally, the patterns were easier
  # to construct and this method more robust, because this method
  # generated search regexps on the fly; however, this was
  # computationally expensive and slowed down the entire REXML package
  # considerably, since this is by far the most commonly called method.
  # /^\s*(#{your pattern, with no groups})(.*)/.  The first group
  # will be returned; the second group is used if the consume flag is
  # set.
  # everything after it in the Source.
  # pattern is not found.
  #
  # @param pattern must be a Regexp, and must be in the form of
  # @param consume if true, the pattern returned will be consumed, leaving
  # @return the pattern, if found, or nil if the Source is empty or the
  #
  # source://rexml//lib/rexml/source.rb#77
  def scan(pattern, cons = T.unsafe(nil)); end

  private

  # source://rexml//lib/rexml/source.rb#125
  def detect_encoding; end

  # source://rexml//lib/rexml/source.rb#146
  def encoding_updated; end
end

# source://rexml//lib/rexml/undefinednamespaceexception.rb#4
class REXML::UndefinedNamespaceException < ::REXML::ParseException
  # @return [UndefinedNamespaceException] a new instance of UndefinedNamespaceException
  #
  # source://rexml//lib/rexml/undefinednamespaceexception.rb#5
  def initialize(prefix, source, parser); end
end
